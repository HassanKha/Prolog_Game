


%Hady Raed Mahmoud : 20175019
%Mohamed Hussein Mohamed : 20176025
%Hassan Khaled : 20176010
%Abdelrahman Gamal Hussein : 20175009
%Fatma Hesham Ahmed : 20176019

dim([3,3]).
nextplayer(human,computer).
nextplayer(computer,human).
intialBoard([1,-1,0,1,0,1,0,1,-1]).
startPos([2,0]).

%game base
%check dimention of new green postion
checkValidtyOfNewPostion([R,C]):-
    dim([RR,RC]),
    R<RR,
    R>=0,
    C<RC,
    RC>=0.



replace([_|T], 0, X, [X|T]).
replace([H|T], I, X, [H|R]):- I > -1, NI is I-1, replace(T, NI, X, R), !.
replace(L,_, _, L).



%possible Human moves generated by computer
%HUMAN MOVE generated by computer to choose it is best move of computer
adjustGreenNewPos([CR,CC],[NCR,NCC],[NOR,NOC]):-
    NOR is CR,
    NOC is CC,
    NCR is CR,
    NCC is CC-1,
    checkValidtyOfNewPostion([NCR,NCC]).



%human move right
adjustGreenNewPos([CR,CC],[NCR,NCC],[NOR,NOC]):-
    NOR is CR,
    NOC is CC,
    NCR is CR,
    NCC is CC+1.
%human move up
adjustGreenNewPos([CR,CC],[NCR,NCC],[NOR,NOC]):-
    NOR is CR,
    NOC is CC,
    NCR is CR-1,
    NCC is CC,
    checkValidtyOfNewPostion([NCR,NCC]).


%human move down
adjustGreenNewPos([CR,CC],[NCR,NCC],[NOR,NOC]):-
    NOR is CR,
    NOC is CC,
    NCR is CR+1,
    NCC is CC,
    checkValidtyOfNewPostion([NCR,NCC]).



%computer moves
% computer generate 1 on the oldcell
editoldcell([OR,OC],Board,NewBoard):-
    dim([_,B]),
    Index is B*OR+OC,
    replace(Board,Index,1,NewBoard).


% computer generate 0 on the oldcell

editoldcell([OR,OC],Board,NewBoard):-
    dim([_,B]),
    Index is B*OR+OC,
    replace(Board,Index,0,NewBoard).

% computer generate -1 on the oldcell

editoldcell([OR,OC],Board,NewBoard):-
    dim([_,B]),
    Index is B*OR+OC,
    replace(Board,Index,-1,NewBoard).






% generate board after computer act like human and get human possible
% moves and it change according to dim
newHumanBoard([CR,CC],[NCR,NCC],[_,_],Board,NewBoard):-
    dim([_,B]),
    IndexCP is B*CR+CC,
    nth0(IndexCP,Board,Value1),
    IndexNCP is B*NCR+NCC,
    nth0(IndexNCP,Board,Value2),
    NewValue is Value1 + Value2,
    replace(Board,IndexNCP,NewValue ,NewBoard).
   % IndexOCP is B*OR+OC,
   % replace(Board,IndexOCP,0,NewBoard).

%generate all computer moves in the old cell and it always 3 moves

newComputerBoard(Oldpos,Board,NewBoard):-
    editoldcell(Oldpos,Board,NewBoard).



%..................................................................

% when to win if all the moves end compare last green pos with min level
% goal
% if  human acheive more than target it will win with val 1
% else if human acheive less than target it will win to computer with
% val -1
% else if human acheive equel  target it will draw to both with val 0
% else there is still moves state will be play
getNewValue(NewBoard,[R,C],NV):-
   dim([_,B]),
   Index is B*R+C,
   nth0(Index,NewBoard,NV).


getNewState(NS,V,Remmoves,G):-
    V>G,
    Remmoves is 1,
    NS=win.

getNewState(NS,V,Remmoves,G):-
    V<G,
    Remmoves is 1,
    NS=win.

getNewState(NS,V,Remmoves,G):-
    V=G,
    Remmoves is 1,
    NS=draw.

getNewState(NS,_,Remmoves,_):-
    Remmoves>1,
    NS=play.

%..................................................................

decremenmovement(A,B):-
    B is A-1.

% get moves of compute and human all posible generated my computer and
% not human

move([human,State,Currpos,Oldpos,Board,RemMov],[X2,NewState,Newcurrpos,Newoldpos,NewBoard,NRemMov],Goal):-
    RemMov>0,
    humanMove([human,State,Currpos,Oldpos,Board,RemMov],[X2,NewState,Newcurrpos,Newoldpos,NewBoard,NRemMov],Goal),
    decremenmovement(RemMov,NRemMov).

move([computer,State,Currpos,Oldpos,Board,RemMov],[X2,NewState,Newcurrpos,Newoldpos,NewBoard,NRemMov],Goal):-
    RemMov>0,
    computerMove([computer,State,Currpos,Oldpos,Board,RemMov],[X2,NewState,Newcurrpos,Newoldpos,NewBoard,NRemMov],Goal),
    decremenmovement(RemMov,NRemMov).


humanMove([X1,_,Currpos,Oldpos,Board,RM],[X2,NewState,Newcurrpos,Newoldpos,NewBoard,_],Goal):-
  nextplayer(X1,X2),
  adjustGreenNewPos(Currpos,Newcurrpos,Newoldpos),
  newHumanBoard(Currpos,Newcurrpos,Oldpos,Board,NewBoard),
  getNewValue(NewBoard,Newcurrpos,NV),
  getNewState(NewState,NV,RM,Goal).

computerMove([X1,_,Currpos,Oldpos,Board,RM],[X2,NewState,Newcurrpos,Newoldpos,NewBoard,_],Goal):-
  nextplayer(X1,X2),
  Newcurrpos = Currpos,
  Newoldpos =  Oldpos,
  newComputerBoard(Oldpos,Board,NewBoard),
  getNewValue(NewBoard,Newcurrpos,NV),
  getNewState(NewState,NV,RM,Goal).



%..............................................................\
%alphabeta algorith



%min_to_move(+Pos):True if the next player to play is the MIN player.
min_to_move([computer,_, _,_,_]).


%max_to_move(+Pos): True if the next player to play is the MAX player.
max_to_move([human,_,_,_,_]).




% utility(+Pos, -Val) :-
% True if Val the the result of the evaluation function at Pos.
% We will only evaluate for final position.
% So we will only have MAX win, MIN win or draw.
% We will use  1 when MAX win
%             -1 when MIN win
%              0 otherwise.
utility([human, win, _,_,_,_], 1).
% Previous player (MAX) has win.

utility([computer, win, _,_,_,_], -1).
% Previous player (MIN) has win.

utility([_,draw,_,_,_,_], 0).

% minimax(Pos, BestNextPos, Val)
% Pos is a position, Val is its minimax value.
% Best move from Pos leads to position BestNextPos.
alpha_Beta(Pos,Alpha,Beta, BestNextPos, Val,Goal) :-                     % Pos has successors
    bagof(NextPos, move(Pos, NextPos ,Goal), NextPosList),
    best(NextPosList,Alpha,Beta, BestNextPos, Val,Goal), !.

alpha_Beta(Pos,_,_, _, Val,_) :-                     % Pos has no successors
    utility(Pos, Val).




best([Pos1 | PosList],Alpha,Beta, BestPos, BestVal,Goal) :-
    alpha_Beta(Pos1,Alpha,Beta, _, Val1,Goal),
    goodenough( PosList, Alpha, Beta, Pos1, Val1, BestPos, BestVal,Goal).



goodenough( [], _, _, Pos, Val, Pos, Val,_)  :-  !.    % No other candidate



goodenough( _, Alpha, Beta, Pos, Val, Pos, Val,_)  :-
	min_to_move( Pos), Val > Beta, !                   % Maximizer attained upper bound
	;
	max_to_move( Pos), Val < Alpha, !.                 % Minimizer attained lower bound



goodenough( PosList, Alpha, Beta, Pos, Val, GoodPos, GoodVal,Goal)  :-
	newbounds( Alpha, Beta, Pos, Val, NewAlpha, NewBeta),    % Refine bounds
	best( PosList, NewAlpha, NewBeta, Pos1, Val1,Goal),
	betterof( Pos, Val, Pos1, Val1, GoodPos, GoodVal).



newbounds( Alpha, Beta, Pos, Val, Val, Beta)  :-
	min_to_move( Pos), Val > Alpha, !.                 % Maximizer increased lower bound

newbounds( Alpha, Beta, Pos, Val, Alpha, Val)  :-
	max_to_move( Pos), Val < Beta, !.                 % Minimizer decreased upper bound

newbounds( Alpha, Beta, _, _, Alpha, Beta).          % Otherwise bounds unchanged


betterof( Pos, Val, _, Val1, Pos, Val)  :-        % Pos better than Pos1
	min_to_move( Pos), Val > Val1, !
	;
	max_to_move( Pos), Val < Val1, !.

betterof( _, _, Pos1, Val1, Pos1, Val1).             % Otherwise Pos1 better







humanBmove([X1,State,Currpos,Oldpos,Board,M],[X2,NewState,Newcurrpos,Newoldpos,NewBoard,NM],Direction,G):-
    playHuman([X1,State,Currpos,Oldpos,Board,M],[X2,NewState,Newcurrpos,Newoldpos,NewBoard,NM],Direction,G),
    decremenmovement(M,NM).



%................................................................
%the game




game :-


  nl,

    write('===================='),

  nl,    write('= Prolog H&M Game  ='),

  nl,

    write('===================='),

  nl,

  nl,

 write('What is Minimal Level Goal ?'),
 nl, read(Goal), nl,

 nl,
 write('What is Maximum number of moves ?'),
 nl, read(MM), nl,
 nl,

write('Rem : Player starts the game'),

  nl,
intialBoard(B),
show(B,_,computer), nl,
startPos(Begin),
M is MM *2,
play([human,play,Begin,null,B,M],human,Goal).






play([Player,State,Greencp,_,Board,Movs],human,Goal) :-

  !,

 nl,
 write('Next move ?'),
 nl, read(Direction), nl,

  %check validity of direction enter by real player
  dim([RR,RC]),
  bestHumanMove(Greencp,[NR,NC],[NOR,NOC],Direction),

 (    NR>=0 ;  write('Error : not a valid Direction !'),
			  nl, play([Player,State,Greencp,_,Board,Movs],human,Goal)
 )
 ,
 (    NR<RR ;  write('Error : not a valid Direction !'),
			  nl, play([Player,State,Greencp,_,Board,Movs],human,Goal)
 )
 ,

(  NC>=0  ;  write('Error : not a valid Direction !'),
			  nl, play([Player,State,Greencp,_,Board,Movs],human,Goal)
 )
 ,

(   NC<RC ;  write('Error : not a valid Direction !'),
			  nl, play([Player,State,Greencp,_,Board,Movs],human,Goal)
 )
 ,




   % Ask human where to play
humanBmove([Player,State,Greencp,[NOR,NOC],Board,Movs],[NextPlayer,NewState,Newcurrpos,Newoldpos,NewBoard,NM],Direction,Goal),
 (
      show(NewBoard,Newoldpos,human),
      NewState = win, !,

      % If Player win -> stop

      nl, write('End of game : '),

      write(Player), write(' win !'), nl, nl

      ;
      NewState = draw, !,
     % If draw -> stop
      nl, write('End of game : '), write(' draw !'), nl, nl

      ;play([NextPlayer,NewState,Newcurrpos,Newoldpos,NewBoard,NM],computer,Goal)).










play([Player,State,Greencp,Oldpos,Board,Movs],computer,Goal) :-

nl, write('Computer play : '), nl, nl,
% Compute the best move
 bestMove([Player,State,Greencp,Oldpos,Board,Movs],[NextPlayer,NewState,Newcurrpos,Newoldpos,NewBoard,NM],Goal),
 show(NewBoard,_,computer),

    (

      NewState = win, !,

      % If Player win -> stop

      nl, write('End of game : '),
      getNewValue(NewBoard,Greencp,V),

            (V>Goal->write(' human win !') ,break, nl, nl,!;write(' computer win !'),break,nl, nl,!),!,nl;


      NewState = draw, !,
     % If draw -> stop
      nl, write('End of game : '), write(' draw !'),break, nl, nl

      ;
     % Else -> continue the game

      play([NextPlayer,NewState,Newcurrpos,Newoldpos,NewBoard,NM], human,Goal)

    ).




bestMove(Pos, NextPos,Goal):-
	alpha_Beta(Pos,-10000,10000,NextPos,_,Goal).



%real player functions
%....................when human choose cell to go.....................
%real Human moves not computer as human
%HUMAN MOVE LEFT.
bestHumanMove([CR,CC],[NCR,NCC],[NOR,NOC],left):-
    NOR is CR,
    NOC is CC,
    NCR is CR,
    NCC is CC-1.

%human move right
bestHumanMove([CR,CC],[NCR,NCC],[NOR,NOC],right):-
    NOR is CR,
    NOC is CC,
    NCR is CR,
    NCC is CC+1.

%human move down
bestHumanMove([CR,CC],[NCR,NCC],[NOR,NOC],down):-
    NOR is CR,
    NOC is CC,
    NCR is CR+1,
    NCC is CC.


%human move up
bestHumanMove([CR,CC],[NCR,NCC],[NOR,NOC],up):-
    NOR is CR,
    NOC is CC,
    NCR is CR-1,
    NCC is CC.

%create new board depend on human choice



playHuman([X1,_,Currpos,Oldpos,Board,M],[X2,NewState,Newcurrpos,Newoldpos,NewBoard,_],D,G):-
   nextplayer(X1,X2),
   bestHumanMove(Currpos,Newcurrpos,Newoldpos,D),
   newHumanBoard(Currpos,Newcurrpos,Oldpos,Board,NewBoard),
   getNewValue(NewBoard,Newcurrpos,NV),
   getNewState(NewState,NV,M,G).


%.......................................................................

show(Board,[CR,CC],human) :-
       dim([_,B]),
       Index is B*CR+CC,
       replace(Board,Index,o,[X1,X2,X3,X4,X5,X6,X7,X8,X9]),
       (X1=o->write('   '), show2("");
        write('   '), show2(X1)),

       (X2=o->write(' | '), show2("");
        write(' | '), show2(X2)),

       (X3=o->write('  | '), show2("");
        write(' | '), show2(X3)),nl,

        write('  -----------'), nl,

       (X4=o->write('   '), show2("");
        write('   '), show2(X4)),

       (X5=o->write(' | '), show2("");
        write(' | '), show2(X5)),

       (X6=o->write(' | '), show2("");
        write(' | '), show2(X6)),nl,

        write('  -----------'), nl,

       (X7=o->write('   '), show2("");
        write('   '), show2(X7)),

       (X8=o->write(' | '), show2("");
        write(' | '), show2(X8)),

       (X9=o->write(' | '), show2("");
        write(' | '), show2(X9)),nl.



show([X1, X2, X3, X4, X5, X6, X7, X8, X9],_,computer) :-


	write('   '), show2(X1),

	write(' | '), show2(X2),

	write(' | '), show2(X3), nl,

	write('  -----------'), nl,

	write('   '), show2(X4),

	write(' | '), show2(X5),

	write(' | '), show2(X6), nl,

	write('  -----------'), nl,

	write('   '), show2(X7), write(' | '), show2(X8),

	write(' | '), show2(X9), nl.







% show2(+Term)

% Write the term to current outupt

% Replace 0 by ' '.



show2(X):-

  write(X).


% --------------------------------------------------------------------------------
